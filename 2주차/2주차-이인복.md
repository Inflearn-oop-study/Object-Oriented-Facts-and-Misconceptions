# Chapter02 - 이상한 나라의 객체

### 📌 객체지향의 패러다임과 인간의 인지 능력
- 객체지향이 쉽게 받아들여지는 이유는 세상을 객체 단위로 분해할 수 있는 인간의 기본적인 인지능력에 기반을 두어서다.
  - 복잡한 세상을 극복하기 위한 인간의 노력
- 인간은 구체적인 사물뿐 아니라 개념적으로도 객ㅊ체를 구분해 인식할 수 있다.
  - ex) 물리적 - 사람 / 개념적 - 저녁 주문 내역
- 상태를 결정하는 건 '행동', 행동의 결과를 결정하는건 '상태'

```
❓ 의문점: 행동의 결과를 결정하는게 상태인가 라는 의문점이 생겼다.
❗️ 나름의 해석: 상태에 따라서 행동이 결과에 미치지 않기 때문이지 않을까?
❗️ 책 ex1): 행동에 대한 결과가 상태에 영향을 미치지만 기존에 있던 상태에 결과가 의존적이기 때문에
❗️ 책 ex2): 엘리스 키에 따라서 문을 통과할 수 있는 여부가 갈린다.
```

- 상태가 변함에도 객체 자체에는 변함없이 식별 가능해야 한다.
  - ex) 엘리스가 키가 커지던, 위치가 달라지던 엘리스는 엘리스다.

****

### 📌 상태(State), 행동(Behavior), 식별자(Identity)
- 셀 수 있어야 한다.
- 생성 시점을 알 수 있어야 한다.
- 하나의 독립된 단위로 인식 가능해야 한다.

#### ⚙︎ 상태는 왜 필요할까?
상태는 상호작용이 일어나기 전 까지 어떤 일이 발생했는가에 따라서 결정된다.  
모든 행동에 대해서 기억하는 것은 쉽지 않은 방향이기 때문에 행동에 따른 결과를 상태에 반영해서 저장한다.

#### ⚙︎ 상태와 프로퍼티
- 각 상태를 표현하는 값 들은 객체의 프로퍼티(Property)라 하며 '정적'이다
- 각 프로퍼티가 갖는 값(Attribute)은 시간이 지남에 따라 변경되기 때문에 '동적'이다.
- 객체가 다른 객체와 연결(링크)되어 있음은 '참조'하고 있다와 동일하며, 링크가 끊기게 되면 더 이상 협력이 불가능하다.

#### ⚙︎ 상태와 행동
객체의 상태는 스스로 변하지 않는다.  
객체의 행동은 객체의 상태를 변경 시키며, 행동의 결과는 상태에 의존적이다.  
행동은 과거 어떤 행동을 했나에는 의존적이지 않지만, 그 행동에 대한 결과에 의존적이다.

#### ⚙︎ 협력과 행동
객체가 다른 객체와 협력하기 위해서 요청을 보내면, 수신한 객체는 응답한다.  
협력에 참여하는 객체는 응답에 따른 자신의 상태도 변경되며 행동은 외부에 가시적이여야 한다.

#### ⚙︎ 상태의 캡슐화
객체의 상태를 변경시키는 주체는 객체 자신이어야 한다.  
협력으로 인한 다른 객체의 상태에 대해서는 메세지를 통해서 전달하고, 상태 변경에 대해서는 전달한 객체에게 책임을 맡긴다.  
결과적으로 객체 개인에게 책임이 주어지면서 판단하고, 결정하게 하는건 객체의 자율성을 높이는 것과 같다.

#### ⚙︎ 식별자
- 식별자: 객체를 구별할 수 있는 특정한 프로퍼티(Property)
- 값(Value): 변하지 않는 양을 모델링하는 단위(불변상태, Immutable State)
  - ex) 책과 공책 그리고 테블릿에 '1'이라는 숫자가 적혀 있다고, 다 다른 값으로 인지하지 않는다.
- 동등성(Equality): 상태를 이용해 두 값이 같은지 판단하는 성질
  - ex) 애플워치가 2개 있고, 모든 설정이 같아도 시리얼 번호가 틀리고, 인식할 때 별개의 객체로 본다.(하지만 설정은 변경 가능한 상태이고 이를 가변상태, Mutable State)

#### ⚙︎ 행동이 상태를 결정한다
상태를 중심으로 객체를 바라보는건 잘못된 방법이다. (헐...)  
  
1. 상태에 초점을 맞춘 경우 캡슐화 실패의 원인이 된다. (구체적인 예시는 없나?) 
2. 객체는 다른 객체와 협력하기 위해 필요한데, 상태 먼저 고려하게 되면 다른 객체와의 협력이 뒤로 밀리게되고 협력적이지 않은 객체 디자인의 발판이 된다.
3. 협력에 초점을 두지 않았기 때문에 재사용성 또한 저하된다.

결론: 객체를 협력적으로 설계하기 위해서는 상태보다 행동이 우선시 되어야하고, 객체가 협력 안에서 행동한다는 것은 책임을 완수해야만 한다는 의미이다. (Responsibility-Driven Design, RDD)

****

### 📌 은유와 객체
#### ⚙︎ 현실과 소프트웨어의 객체의 차이점은 무엇일까?
현실에서 수동적인 객체도 소프트웨어의 객체로 구현되면서 능동적으로 변한다.  
왜? 추가적인 능력을 부여함으로써 객체 스스로 자율적으로 판단하고, 책임을 갖도록 하여 모방보다 창조에 가까운 작업을 하게된다.

- 의인화(Anthropomorphism): 현실에서는 수동적 객체들은 인간이라는 에이전트에 의존하고 있어서 인간 없이는 실행이 불가능 하지만 소프트웨어 안에서는 가능하다.
- 은유(Metaphor): 한 종류의 사물을 다른 종류의 사물 관점에서 이해하고 경험하는 것
  - 현실 구조를 정확히 반영해야 한다는 '오해'를 하게 하는 단어는 '모방'이다.
  - 은유를 통해서 개념을 묘사하면 소프트웨어의 객체가 하는 역할에 대한 이해가 쉽게 가능하다.
  - 차이: 사람들이 생각하는 모습과 실제 소프트웨어의 표현 사이의 차이
    - 표현적 차이(Representational Gap) 혹은 의미적 차이(Sementic Gap): 은유 관계의 객체의 이름을 소프트웨어의 객체의 이름으로 사용하면 표현적 차이가 줄어든다. 

****

# Chapter03 - 타입과 추상화체
지하철 노선도에 지형 지물에 대한 정보가 필요 있을까?  
단순히 목적지에 도착하기 위해 어느 노선도를 타고, 갈아탈 위치를 알 수 있는 목적에만 충실한 정보만 알면되지 않을까?  
'정확'한 정보를 위해서 '목적'을 흐리게 되면 중요한 정보를 놓치게 한다.

> 나: 지하철을 타기 위해서 지형의 높,낮이 그리고 운전사 혹은 다른 정보들은 알 필요가 없으니까 목적에 맞지 않는 정보는 독이 된다.  
> 우리가 하드웨어를 사용할 때 복잡한 하드웨어의 동작을 전부 이해하고 사용하지는 않으니까 (심하게는 하드웨어를 몰라도 우리는 사용 가능하다.)

추상화의 성공 '요인' 으로는 고객의 니즈에 맞아야 한다는 것이다.
- 승객들은 지하철을 타고 목적지로 가는 것이 '목적' 이다.
- 개발자는 코드를 통해서 컴퓨터에게 일을 시키는게 목적이다. (복잡한 하드웨어까지 하나하나 조작하는게 아니라)

추상화란 현실에서 출발해 불필요한 부분을 도려내어 사물의 본질을 드러나게 하는 과정으로 복잡한 현상에서 버릴게 무엇인지 아는게 중요하다.

**** 

### 📌 객체지향의 추상화
객체지향 패러다임에서의 '객체' 는 명확한 경계를 가지고 서로 구별이 가능해야 한다.  
ex) 짱구, 철수, 유리는 '사람' 이라는 이지만 식별이 가능하다.

소설에서 엘리스는 고작 '트펌프' 라는 단어로 다양한 객체를 하나의 그룹으로 묶었다.
```
                                트럼프
                                  |
-----------------------------------------------------------------------------
   |     |     |     |    |     |    |    |     |      |        |        |
[정원사] [병사] [신하] [왕자] [공주] [하객] [왕] [왕비] [하트] [하트 잭] [하트 왕] [하트 여왕]
```
다양한 역할을 하는 객체 이지만 작중에서 엘리스는 의도적으로 차이점을 무시한채 공통점을 강조해 그룹으로 만드는 일종의 추상화를 했다.
- 개념(Concept): 우리가 인식하는 다양한 사물이나 객체에 적용할 수 있는 관념 (하나의 그룹)
- 분류(Classification): 공통점을 기반으로 객체를 나누는 것
- 인스턴스(Instance): 객체가 개념이 적용되어 그 일원이 된 객체
  - 개념이 객체에 적용됐을 때 객체를 개념의 인스턴스라 부른다.

#### ⚙ 개념의 세 가지 관점
- 심볼(Symbol): 개념을 가르키는 이름이나 명칭 -> '트럼프'
- 내연(Intension): 개념의 완벽한 정의로 객체가 개념에 속하는지 판단 -> '개념'
- 외연(Extension): 개념에 속하는 모든 객체의 집합(set)

****

### 📌 타입
#### ⚙︎ 타입은란?
타입(Type)은 개념(Concept)의 다른 말이다.  
컴퓨터 데이터에 들어있는 데이터는 단 하나의 타입 '타입 없음'(Untyped)로 0과 1로만 표현되는 비트열(Bit String)이다.  
0과 1로 이루어진 값은 숫자인지, 문자인지도 구분할 수 없는 무수히 많은 혼란을 야기하는 데이터다.  
  
그렇기 때문에 타입 시스템(Type System)이 자리를 잡고, 주된 목적 데이터가 잘못 사용되지 않도록 제약사항을 부과하는 것이다.
- 숫자: 산술기호(+, -, *, /)가 적용 가능한 데이터

객체지향에서 객체를 타입에 따라 분류하고, 타입에 이름을 붙이는 것은 새로운 데이터 타입을 선언하는 것과 같지만, 객체를 데이터로 볼 수는 없다.
객체의 '상태' 는 '행위' 에 따라서 변하지만, 객체 '창조' 시 중요한 점은 다른 객체와 협력시 어떤 '행동' 을 할지 결정하는 것이다.  

객체지향 설계의 중요한 원칙
1. 객체의 타입은 객체의 행동에 따라서 결정된다.
  - 같은 행동을 하는 객체는 같은 타입으로 분류된다.
2. 내부적인 표현은 외부로부터 감춰줘야 한다.
  - 내부에서 어떻게 상태가 관리되던 행동이 같다면 같은 타입이다.
    - 객체가 어떤 데이터를 어떤 타입으로 관리하던 상관이 없다는 말

#### ⚙︎ 행동이 우선이다
위에서 설명한 것과 같이 객체 내부에 데이터가 어떻게 관리가 되는 것과는 별개로 '행동' 에 따라서 분류가 된다.  
이는 객체지향의 '다형성' 에 관한 이야기로 객체 내부에 데이터들이 다르게 관리되고 있기 때문에 같은 행동이여도 다른 방식으로 응답해야 한다.
외부로부터 내부 데이터 관리에 대해새는 행동의 뒤로 감춰두는걸 '캡슐화' 라고 한다.
  
데이터를 먼저 결정하고 객체의 책임을 결정하는 방법 (Data Driven Design, DDD)은 유연하지 못한 설계를 갖는 단점이 있고, 극복하기 위해서 책임 주도 설계(Responsibility Driven Design)이 고안되었다.

****

### 📌 타입의 계층
#### ⚙ 일반화/특수화(Generalization/Specialization) = 슈퍼타입/서브타입(Supertype/Subtype)
객체도 일반적인 개념이 있고, 그에 더해서 조금 더 특별한 행동이 가능한 특수한 개념이 있다.  
특수화 개념도 '행동' 을 기준으로 나뉘어진다.
```
    차량(Interface)
          |
    수송차량 implements 차량: 물품 및 사람 수송
          |
    장갑차 extends 수송차량: 수송 + 전투

내가 생각한 예시에 대한 도식화
```
특수한 타입은 더 많은 일을 할 수 있지만 외연을 의미하는 집합의 크기는 일반화 보다 적다.
```
    ------- 트럼프 -------
    |   |--트럼프인간--|  |
    |   |           |  |
    |   |-----------|  |
    |------------------|
```

****

### 📌 정적 모델
#### ⚙︎ 타입
타입은 '상태' 의 동적인 변화와는 무관한 정적 모습으로 객체를 다룰 수 있도록 해준다.  
객체의 동적인 특성을 '추상화' 할 수 있게 해줘 복잡한 상태 변화를 단순하게 해준다.  

> '엘리스' 의 경우 시간에 따라 키가 변하는데 키라는 '상태' 가 변한다고 엘리스가 다른 객체가 되는게 아니라 고유한 엘리스 라는 사람을 유지한다.

#### ⚙︎ 동적 모델과 정적 모델
- 스냅샷(Snapshot): 객체가 특정 시점에 구체적인 상태를 갖는지에 대한 정보(= 객체 다이어그램)
  - 객체의 생명주기동안 변화는 모습을 담는게 동적 모델(Dynamic Model)이라고 한다.
- 타입 모델(Type Model): 시간에 독립적인 상태, 행동 표현
  - 변하는 객체의 상태가 아니라 '객체가 속한 타입' 을 표현해 정적 모델(Static Model)이라고 한다.
  
※ 클래스와 타입 구현은 다르다.
'클래스' 는 타입 구현 이외에도 코드 재사용 용도로도 쓰이기 때문에 완전히 같지 않다.  
'타입' 은 객체를 분류하기 위해서 사용하는 '개념' 이다.
