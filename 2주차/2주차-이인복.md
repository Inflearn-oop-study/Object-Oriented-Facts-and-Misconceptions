# 학습 내용 주관적 정리

### 📌 객체지향의 패러다임과 인간의 인지 능력
- 객체지향이 쉽게 받아들여지는 이유는 세상을 객체 단위로 분해할 수 있는 인간의 기본적인 인지능력에 기반을 두어서다.
  - 복잡한 세상을 극복하기 위한 인간의 노력
- 인간은 구체적인 사물뿐 아니라 개념적으로도 객ㅊ체를 구분해 인식할 수 있다.
  - ex) 물리적 - 사람 / 개념적 - 저녁 주문 내역
- 상태를 결정하는 건 '행동', 행동의 결과를 결정하는건 '상태'

```
❓ 의문점: 행동의 결과를 결정하는게 상태인가 라는 의문점이 생겼다.
❗️ 나름의 해석: 상태에 따라서 행동이 결과에 미치지 않기 때문이지 않을까?
❗️ 책 ex1): 행동에 대한 결과가 상태에 영향을 미치지만 기존에 있던 상태에 결과가 의존적이기 때문에
❗️ 책 ex2): 엘리스 키에 따라서 문을 통과할 수 있는 여부가 갈린다.
```

- 상태가 변함에도 객체 자체에는 변함없이 식별 가능해야 한다.
  - ex) 엘리스가 키가 커지던, 위치가 달라지던 엘리스는 엘리스다.

### 📌 상태(State), 행동(Behavior), 식별자(Identity)
- 셀 수 있어야 한다.
- 생성 시점을 알 수 있어야 한다.
- 하나의 독립된 단위로 인식 가능해야 한다.

#### ⚙︎ 상태는 왜 필요할까?
상태는 상호작용이 일어나기 전 까지 어떤 일이 발생했는가에 따라서 결정된다.  
모든 행동에 대해서 기억하는 것은 쉽지 않은 방향이기 때문에 행동에 따른 결과를 상태에 반영해서 저장한다.

#### ⚙︎ 상태와 프로퍼티
- 각 상태를 표현하는 값 들은 객체의 프로퍼티(Property)라 하며 '정적'이다
- 각 프로퍼티가 갖는 값(Attribute)은 시간이 지남에 따라 변경되기 때문에 '동적'이다.
- 객체가 다른 객체와 연결(링크)되어 있음은 '참조'하고 있다와 동일하며, 링크가 끊기게 되면 더 이상 협력이 불가능하다.

#### ⚙︎ 상태와 행동
객체의 상태는 스스로 변하지 않는다.  
객체의 행동은 객체의 상태를 변경 시키며, 행동의 결과는 상태에 의존적이다.  
행동은 과거 어떤 행동을 했나에는 의존적이지 않지만, 그 행동에 대한 결과에 의존적이다.

#### ⚙︎ 협력과 행동
객체가 다른 객체와 협력하기 위해서 요청을 보내면, 수신한 객체는 응답한다.  
협력에 참여하는 객체는 응답에 따른 자신의 상태도 변경되며 행동은 외부에 가시적이여야 한다.

#### ⚙︎ 상태의 캡슐화
객체의 상태를 변경시키는 주체는 객체 자신이어야 한다.  
협력으로 인한 다른 객체의 상태에 대해서는 메세지를 통해서 전달하고, 상태 변경에 대해서는 전달한 객체에게 책임을 맡긴다.  
결과적으로 객체 개인에게 책임이 주어지면서 판단하고, 결정하게 하는건 객체의 자율성을 높이는 것과 같다.

#### ⚙︎ 식별자
- 식별자: 객체를 구별할 수 있는 특정한 프로퍼티(Property)
- 값(Value): 변하지 않는 양을 모델링하는 단위(불변상태, Immutable State)
  - ex) 책과 공책 그리고 테블릿에 '1'이라는 숫자가 적혀 있다고, 다 다른 값으로 인지하지 않는다.
- 동등성(Equality): 상태를 이용해 두 값이 같은지 판단하는 성질
  - ex) 애플워치가 2개 있고, 모든 설정이 같아도 시리얼 번호가 틀리고, 인식할 때 별개의 객체로 본다.(하지만 설정은 변경 가능한 상태이고 이를 가변상태, Mutable State)

#### ⚙︎ 행동이 상태를 결정한다
상태를 중심으로 객체를 바라보는건 잘못된 방법이다. (헐...)  
  
1. 상태에 초점을 맞춘 경우 캡슐화 실패의 원인이 된다. (구체적인 예시는 없나?) 
2. 객체는 다른 객체와 협력하기 위해 필요한데, 상태 먼저 고려하게 되면 다른 객체와의 협력이 뒤로 밀리게되고 협력적이지 않은 객체 디자인의 발판이 된다.
3. 협력에 초점을 두지 않았기 때문에 재사용성 또한 저하된다.

결론: 객체를 협력적으로 설계하기 위해서는 상태보다 행동이 우선시 되어야하고, 객체가 협력 안에서 행동한다는 것은 책임을 완수해야만 한다는 의미이다. (Responsibility-Driven Design, RDD)

### 📌 은유와 객체
#### ⚙︎ 현실과 소프트웨어의 객체의 차이점은 무엇일까?
현실에서 수동적인 객체도 소프트웨어의 객체로 구현되면서 능동적으로 변한다.  
왜? 추가적인 능력을 부여함으로써 객체 스스로 자율적으로 판단하고, 책임을 갖도록 하여 모방보다 창조에 가까운 작업을 하게된다.

- 의인화(Anthropomorphism): 현실에서는 수동적 객체들은 인간이라는 에이전트에 의존하고 있어서 인간 없이는 실행이 불가능 하지만 소프트웨어 안에서는 가능하다.
- 은유(Metaphor): 한 종류의 사물을 다른 종류의 사물 관점에서 이해하고 경험하는 것
  - 현실 구조를 정확히 반영해야 한다는 '오해'를 하게 하는 단어는 '모방'이다.
  - 은유를 통해서 개념을 묘사하면 소프트웨어의 객체가 하는 역할에 대한 이해가 쉽게 가능하다.
  - 차이: 사람들이 생각하는 모습과 실제 소프트웨어의 표현 사이의 차이
    - 표현적 차이(Representational Gap) 혹은 의미적 차이(Sementic Gap): 은유 관계의 객체의 이름을 소프트웨어의 객체의 이름으로 사용하면 표현적 차이가 줄어든다. 
