# Chapter04 - 역할, 책임, 협력
최후통첩 게임(Ultimatum Game) 을 예시로 결과를 도출 했을때 인간이 어떤 본질적인 특성을 지니고 있느냐가 아니라  
상황에 처해 있느냐에 따라서 '행동' 이 결정된다.

정황 또는 문맥(Context) 가 인간의 행동을 결정하며, 여기서 말하는 문맥은 타인과의 협력을 말한다.
> 앞서 말했던 상태보다 행동을 먼저 설계하고 그에 맞게 상태를 결정 했다면  
> 이번 챕터에서는 행동을 생각하기전에 객체간의 협력에 초점을 맞춰야 한다고 말한다.  
> '협력' 이 자리 잡으면 '행동' 이 들어나고, 적절한 '상태' 가 결정된다.

앞장에서는 객체들의 개별적인 관점에서 다뤘기 때문에 '상태' 와 '행동' 을 다뤘고, 이번 장에서는 객체간의 '협력' 이다.

### 📌 협력
협력은 요청과 응답으로 이루어지고, 문제를 해결하기 위해서 요청과 응답이 연쇄적으로 발생한다.

'요청' 을 받거나 보낸다는 의미는 무언가를 수행해야할 '의무' 가 있다는 말이다.  
요청을 받고 '응답' 을 해야 하는 이유는 '책임' 이 있기 때문이다.

****

### 📌 책임
책임의 분류를 나눴을 때 객체가 무엇을 알고 있는가(Knowing) 과 무엇을 할 수 있는가(Doing) 으로 나눈다.

- 하는 것(Doing)
  - 객체 생성, 계산 등 스스로 수행하는 것
  - 다른 객체의 행동을 시작
  - 다른 객체의 활동을 제어및 조절
- 아는 것(Knowing)
  - 개인적인 정보에 관해 아는 것
  - 관련된 객체를 아는 것
  - 자신이 유도하거나 계산할 수 있는것에 아는것

```
객체 본인이 할 수 있는 것과 다른 객체에 요청을 보내 작업을 수행시키는 것을 하는 것의 범주에 보는 것 같고,  

아는 것은 어떤 객체가 무슨 역할에 대한 책임을 갖는지 알아야 요청을 보낼 수 있기 때문에 언급 되는거 같다.
```

책임을 이야기 할 때 외부에서 접근 가능한 고용 서비스의 관점에서 외부에 제공 가능한 '정보' 와 '서비스' 목록이라 한다.  
책임은 객체의 공용 인터페이스(Public Interface)를 구성한다.

```
Java의 인터페이스를 생각해보면 변수는 기본적으로 public static final 로 접근 가능한 변하지 않는 정보를 제공하고,  
구현해야할 메소드의 이름을 제공해 구현체가 어떤 기능을 기본적으로 제공하는지를 알 수 있다. - 이 개념을 말하는 걸까?
```

****

### 📌 역할
역할은 재사용 가능하고 유욘한 객체지향 설계를 낳는 매우 중요한 구성요소이다.

```
역할에 대한 책임만 질 수 있다면 대체되도 무관하기 때문에 객체지향에서 다형성에 해당하는 부분인거 같다.
```

역할은 협력 내에서 다른 객체로 대체할 수 있음을 나타내는 일종의 '표식' 이다.  
아무 객체나 해당 역할을 수행하는 것이 아닌 역할이 맡은 책임을 수행할 수 있어야 한다.

이 개념은 객체지향 설계에서 핵심 개념을 뒷받침한다.
- 단순성(Simplicity)
- 우연성(Flexibility)
- 재사용성(Reusability)

이렇게 역할을 추상화 함으로써 여러 종류의 객체가 참여하는 협력을 '추상화' 할 수 있도록 한다.  
역할의 대체 가능성은 그 역할을 수행할 수 있는 호환성이 충족되어야 하고, 호환성은 책읨의 수행을 의미한다.  
객체는 암시하는 책임보다 더 많은 책임을 갖을 수 있다.

****

### 📌 객체지향 설계 기법
- 책임 주도 설계(Responsibility Driven Design, RDD)
- 디자인 패턴(Design Pattern)
- 테스트 주도 개발(Test Driven Development, TDD)

****

# Chapter05 - 책임과 메시지
집단 크게에 따라서 개인이 갖는 책임의 크기가 결정되고 이를 '책임감 분산'(Diffusion of Responsibility) 이라고 불렀다.  
명확한 책임자가 정해지지 않은 상황에서 책임이 타인에게 있다고 생각하는 케이스가 많다.  
객체들의 세계에서도 명확한 역할과 책임이 주어진 객체들이 상호 협력하는 세계를 이뤄야 한디.

### 📌 자율적인 책임
객체지향 공동체를 구성하는 기본 단위는 '자율적' 인 객체다.  
적절한 책임이 자율적인 객체를, 유연하고 자율적인 객체들이 단순한 협력을 낳고, 객체들이 얼마나 자유로운지에 따라 전체의 품질을 결정한다.

#### ⚙︎ 자신의 의지에 따라 증언할 수 있는 자유
요청은 수신 객체의 책임을 뜻하기 때문에 요청에 내포되어있는 자율성이 없는 경우에는 수신 객체의 자율성을 회손한다.

> 왕이 재판시 '증언하라' 라고 말하는 것과 'ooo을 어디서 어떻게 마주쳤는지' 같이 자세하게 요청하는 것의 차이를 예시로 든다.  
> 첫 번째 예시는 수신 객체가 어떻게 증언하는지 전혀 관혀하지 않지만, 두 번째 예시는 정확히 어떤 세부사항을 원하는지 전부 물어본다.  
> 실제 코드로 생각해보면 인터페이스가 아닌 구현 클래스에 의존해 내부 구현 로직을 전부 의존하고 있는 의존성 높은 설계를 말하고 싶은거 같다.

객체가 자율적이기 위해서는 할당되는 책임의 수준이 자율적이어야 하고, 책임의 수준은 객체가 수신하는 요청에 내포되어 있다.

#### ⚙ 너무 추상적인 책임
위에서 말한 객체의 자율을 제한하는 요청과는 반대로 너무 자율적인 추상적인 요청은 괜찮을까?  
추상적이고 포괄적인 책임은 높은 재사용성과 유연성을 제공하지만 명확한 의도조차 알 수 없는 요청 또한 문제가 된다.  
수신하는 객체는 요청에대한 책임을 갖고 역할을 이행하는데, 요청을 정확히 이해하지 못하면 어떻게 협력이 가능할

문맥에 따라서 좋은 선택이 될 수도, 나쁜 선택이 되 수도 있는 난해한 부분이다.

****

### 📌 메세지와 메소드
#### ⚙ 메세지
객체가 다른 객체에 접근하는 방법으로는 '메세지-전송' 이라는 방법을 사용하며, 메세지의 요청은 '메세지 이름(Message Name)' 이고, 필요한 인자(Argument)
를 통해서 추가 정보를 제공한다.

```
모자장수.증언하라(어제, 왕국)
-> '모자장수' 는 '어제' '왕국' 에서 어떤 일이 일어났는지 '증언하라'
```

수신할 수 있는 메세지의 모양이 객체가 수행할 책임의 모양을 결정한다.  
하지만 책임을 수행하는 방법에 대해서는 외부의 다른 객체들이 알 수 없고, 변경사항 또한 알 수 없다.

> 캘슐화 개념을 말하는 것 같다.

#### ⚙ 메소드
수신한 메세지를 처리하기 위해 내부적으로 선택하는 방법이 메소드다.

```
메세지 수신 -> 처리 가능 여부 확인 -> 책임에 맞는 역할 수행 -> 응답
```

요청으로 메세지를 받았지만 그 방법에 대해서는 전적으로 수신자에의 결정에 좌우되며 이 역할이 메소드이다.

#### ⚙ 다형성
다형성이란 서로 다른 객체가 동일한 메세지에 대해서 다르게 반응하는걸 의미한다.  
이는 메세지에는 '어떻게' 처리하라는 방법은 명시되어 있지 않기 때문에 가능하다.

```
        -> 증언하라(req) -> 모자장수(증인) -> 설실하게 증언(method & res)
왕(판사)  -> 증언하라(req) -> 요리사(증인)  -> 불성실하게 증언(method & res)
        -> 증언하라(req) -> 엘리스(증인)  -> 대충 증언(method & res)
```

증인들의 경우 서로 다른 객체이지만 동일한 역할을 수행한다.  
하지만 또 역할에 대한 행동은 다르게 수행한다.

송신자 입장에서는 수신자들의 구분은 필요 없고, 요청에 대한 응답이 가능하면 된다.  
'다형성' 은 수신자의 종류를 '캡슐화' 한다.

****

### 📌 메세지를 따라라
#### ⚙︎ 객체지향의 핵심, 메세지
클래스 자체는 정적인 추상화 도구 이지만 객체지향의 의미는 객체들이 주고 받는 '메세지' 에 있다.  
그리고 시스템을 살아있게 하는건 클래스가 아니라 '객체' 다.

#### ⚙︎ What/Who 사이클
- what: 어떤 행위를 수행할 것인지 결정
- who: 누가 그 행위를 수행할 것인지 결정
- 행위 = 메세지

협력에 필요한 메세지를 먼저 결정한 다음 메세지를 수신할 후보를 선택한다.  
메세지를 결정하는 시점에서 어떤 객체가 메세지를 수신할 것인지에 대한 정보는 없기 때문에 송신자는 수신자의 내부 상태를 알 수 없다.  
이는 메세지 중심의 설계에서 수신자의 캡슐화를 증진 시키고, 느슨한 결합을 만들어낸다.

****

### 📌 객체 인터페이스
#### ⚙ 인터페이스
1. 사용법만 익히면 내부 구조나 동작 방식은 몰라도 쉽게 조작하고 의사 전달이 가능하다.
2. 작동 방식만 변경하는 것은 사용자에게 영향을 미치지 않는다.
3. 대상이 변경되도 동일한 인터페이스를 제공하면 문제 없이 상호작용한다.

> 기름, 하이브리드, 전기, 수소 자동차들에 대해서 생각해보면 이해가 편함

****

### 📌 느낀점
개별적인 객체들을 어떻게 설계하는가에 따라서 시스템 품질이 달라지며 각 객체는 역할에 맞는 책임을 갖고, 자율적인 판단으로 다른 객체들과
협력하여 객체들의 공동체를 형성한다.  
객체들이 책임을 다하기 위해서는 무엇을 할 수 있는지 혹은 혼자서 처리 불가능한 경우 다른 객체랑 협력하기 위해서 다른 객체들의 정보를
알아야 했다.  
전반적으로 객체들 각 각이 갖고 있어야할 특성들을 서술하고, 그 특성들이 객체지향의 특징으로 이어지는 것 같다.

개별적인 객체들의 특징 후에 객체들이 협력하는 방식과 요청에 따른 응답 과정을 메세지와 메소드에 매칭해서 설명하는데,  
객체지향 언어를 다뤄본 사람들에게는 어느정도 익숙한 부분이라고는 생각이 들지만, 생각만 하는것과 특정한 단어로 정의를 내려보는 것은
차이가 있는 것 같다.  
막연하게 생각만 갖고 있다가 정리되어 있는 글을 보는건 다른 기분라고 생각이 되었습니다.

책이 중반부 넘어와서는 계속해서 반복적인 이야기를 다른 관점과 상황에서 풀어내는데 객체지향 패러다임에서 그 만큼 중요하기 때문이 아닐까
하는 마음이 드네요.

역할, 책임, 협력, 행위, 요청, 응답, 상태, 자율성, 캡슐화 등 등 많은 객체지향에 관련된 단어들을 다시 한 번 되새기는 마음으로
읽고 있습니다.